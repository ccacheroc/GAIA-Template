import pytest
import uuid
from sqlalchemy import select
from app.infrastructure.models.quiz import Quiz, Question, QuestionType
from app.core.deps import SIMPLE_TEACHER_ID

# [Feature: Quiz Management] [Story: QQ-TEACHER-004] [Ticket: QQ-TEACHER-004-BE-T01]

@pytest.mark.asyncio
async def test_reorder_questions_happy_path(client, db_session):
    # 1. Setup: Create Quiz and 3 Questions
    quiz = Quiz(title="Reorder Test Quiz", teacher_id=SIMPLE_TEACHER_ID)
    db_session.add(quiz)
    await db_session.commit()
    await db_session.refresh(quiz)

    q1 = Question(quiz_id=quiz.id, type=QuestionType.TF, content="Q1", sequence=1)
    q2 = Question(quiz_id=quiz.id, type=QuestionType.TF, content="Q2", sequence=2)
    q3 = Question(quiz_id=quiz.id, type=QuestionType.TF, content="Q3", sequence=3)
    
    db_session.add_all([q1, q2, q3])
    await db_session.commit()
    # No need to refresh unless we need the IDs if they were autogenerated, but here they are UUIDs. 
    # Usually SQLAlchemy generates UUIDs client side if default=uuid.uuid4 is set in python, 
    # OR server side. If server side, we need refresh.
    # Looking at models, default=uuid.uuid4 is set.
    await db_session.refresh(q1)
    await db_session.refresh(q2)
    await db_session.refresh(q3)

    # 2. Action: call PATCH /reorder with new sequence (3, 1, 2)
    payload = {
        "items": [
            {"id": str(q1.id), "sequence": 3},
            {"id": str(q2.id), "sequence": 1},
            {"id": str(q3.id), "sequence": 2}
        ]
    }

    response = await client.patch(f"/api/v1/quizzes/{quiz.id}/reorder", json=payload)
    
    # 3. Assertions
    assert response.status_code == 204

    # Verify DB state
    # Refresh objects to get latest state from DB
    await db_session.refresh(q1)
    await db_session.refresh(q2)
    await db_session.refresh(q3)

    assert q1.sequence == 3
    assert q2.sequence == 1
    assert q3.sequence == 2

@pytest.mark.asyncio
async def test_reorder_questions_cross_quiz_validation(client, db_session):
    # 1. Setup: Create two quizzes
    quiz1 = Quiz(title=f"My Quiz {uuid.uuid4()}", teacher_id=SIMPLE_TEACHER_ID)
    quiz2 = Quiz(title=f"Other Quiz {uuid.uuid4()}", teacher_id=SIMPLE_TEACHER_ID)
    db_session.add_all([quiz1, quiz2])
    await db_session.commit()
    # Refresh to get IDs
    await db_session.refresh(quiz1)
    await db_session.refresh(quiz2)
    
    q_quiz2 = Question(quiz_id=quiz2.id, type=QuestionType.TF, content="Q_Other", sequence=1)
    db_session.add(q_quiz2)
    await db_session.commit()
    await db_session.refresh(q_quiz2)

    # 2. Action: Try to update quiz1 with a question from quiz2
    payload = {
        "items": [
            {"id": str(q_quiz2.id), "sequence": 1}
        ]
    }

    response = await client.patch(f"/api/v1/quizzes/{quiz1.id}/reorder", json=payload)

    # 3. Assertions
    assert response.status_code == 400
    assert "One or more question IDs do not belong to this quiz" in response.json()["detail"]

@pytest.mark.asyncio
async def test_reorder_questions_bola(client, db_session):
    # 1. Setup: Quiz belonging to another teacher
    other_teacher_id = uuid.uuid4()
    
    from app.infrastructure.models.user import User
    unique_email = f"other_{uuid.uuid4()}@example.com"
    other_user = User(id=other_teacher_id, email=unique_email, full_name="Other")
    db_session.add(other_user)
    await db_session.commit()
    
    quiz = Quiz(title="Other's Quiz", teacher_id=other_teacher_id)
    db_session.add(quiz)
    await db_session.commit()
    await db_session.refresh(quiz)

    # 2. Action: Authenticated as SIMPLE_TEACHER_ID (default), try to modify other's quiz
    payload = {"items": []}
    response = await client.patch(f"/api/v1/quizzes/{quiz.id}/reorder", json=payload)

    assert response.status_code == 403
